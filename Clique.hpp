#ifndef CLIQUE_HPP
#define CLIQUE_HPP
#include <stdio.h>
#include <vector>
#include <iostream>

using namespace std;

//Forward declaration
class Vertex;
class Demand;
class Path;
class Edge;

struct forbiddenEdgesFromCliques
{
	std::vector<Demand*> 	indexDemand;	// The demands that share this edge
	Edge*					edges;  		// The shared edge (used to build the constraint that will forbid the clique)
};

class Clique
{
	private:
		bool									isSymm;							// indicates if this clique was generated by symmetry searching on another clique
		std::vector<Vertex*>					vertices_; 						// those are actually the demands involved in the clique (their vertices from the intersection graph)
		unsigned 								size_;							// number of involved demands in the clique
		unsigned								weight_;  						// sum of weights (required slots) of composing demands
		unsigned								numberOfChildren_;				// the number of known cliques so far that are included in this clique. if 0, this clique is a circuit
		std::vector<Demand*>					demands_;						// an easier way to access the demands that generated the clique
		std::vector<forbiddenEdgesFromCliques>	forbiddenEdgesFromCliques_; 	// this contains all the edges and demands that share them for MCF constraint creation
		std::vector<Path*>						paths_;							// Paths that originated clique
		std::vector<string>						pathsLabels_;					// names of the pair demand-path for prints
		std::vector<Clique*>					cliqueParents_;					// cliques that contain this clique
		std::vector<Clique*>					cliqueChildren_;				// cliques that this clique contains
		unsigned								index_;							// the index of the clique is updated by the Obstructions class

	public:
		//Constructors
		Clique(unsigned s = 0, unsigned omega = 0): isSymm(false), vertices_(), size_(s), weight_(omega), numberOfChildren_(0) {}
		Clique(std::vector<Vertex*> v);
		Clique(std::vector<Path*>, std::vector<Demand*>, std::vector<std::vector<Path*>*> &);

		//Getters
		const std::vector<Vertex*> &					getVertices() const {return vertices_;}
		std::vector<unsigned>							getDemandIndices() const;
		const unsigned &								getIndex() const {return index_;}
		const unsigned &								getSize() const {return size_;}
		const unsigned &								getOmega() const {return weight_;}
		const std::vector<Demand*> &					getDemands() const {return demands_;}
		const std::vector<forbiddenEdgesFromCliques> &  getForbiddenEdgesFromCliques ()const { return forbiddenEdgesFromCliques_;}
		const std::vector<Path*> & 						getPaths ()const { return paths_;}
		std::vector<Clique*>							getCliqueParents() const {return cliqueParents_;}
		std::vector<Clique*>							getCliqueChildren() const {return cliqueChildren_;}
		unsigned										getNumberOfChildren() const {return numberOfChildren_;}
		bool 											getSymm() {return isSymm;}
		friend ostream &operator<<(std::ostream &flux, const Clique &c);

		//Non constant getters
		std::vector<forbiddenEdgesFromCliques> &  		getForbiddenEdgesFromCliques () { return forbiddenEdgesFromCliques_;}

		//Setters
		void							setDemands(std::vector<Demand*>);
		void							setIndex(unsigned i) {index_ = i;}
		void							setSymm() {isSymm = true;}

		//Functions
		void                            addVertex(Vertex* & v);												//adds a vertex to the clique
		void                            removeTheLastVertex(); 												//remove the last vertex of the clique for backtracking
		bool                            tryAddVertex(Vertex* & v);											//try to add a vertex in the clique if possible

		void                            addForbiddenEdgesFromCliques(Edge* & e, Demand* d1, Demand* d2);	//based in two demands, verify if and which edge they share and saves the information
		void							addPath(string label, Path* & p);									//add path that originated the clique

		void							addCliqueParent(Clique* c) {cliqueParents_.push_back(c);}
		void							addCliqueChild(Clique* c) {cliqueChildren_.push_back(c); numberOfChildren_++;}
		bool							eraseCliqueChild(Clique*);											// returns a bool indicating if the clique is now childless
		void							resetDependencies();												// removes the dependencies relations before its insertion in obstructions

		void							symmetricalSubstitution(Demand*, Demand*);							// creates a symmetrical clique by changing one demand for another
		void							forbiddenEdgesSymmSubstitution(Demand*, Demand*);					// replaces one demand from its forbidden edges by another demand
		void							demandsSymmSubstitution(Demand*, Demand*);							// replaces one demand by another
		void							symmetricalInversion(Demand*, Demand*);								// creates a symmetrical clique by inversion of two demands roles
		void							forbiddenEdgesSymmInversion(Demand*, Demand*);						// inverts the forbidden edges linked to two demands

		bool 							operator==(Clique&) const;

		//Destructors
		~Clique(){}
};

// Overloading flux operator to print object in screen
std::ostream &operator<<(std::ostream &flux, const Clique &c);

#endif // CLIQUE_H
